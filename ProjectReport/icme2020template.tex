% Template for ICME 2020 paper; to be used with:
%          spconf.sty  - ICASSP/ICIP/ICME LaTeX style file, and
%          IEEEbib.bst - IEEE bibliography style file.
% --------------------------------------------------------------------------
\documentclass{article}
\usepackage{spconf,amsmath,epsfig}
% \usepackage{svg}

\let\OLDthebibliography\thebibliography
\renewcommand\thebibliography[1]{
  \OLDthebibliography{#1}
  \setlength{\parskip}{0pt}
  \setlength{\itemsep}{0pt plus 0.3ex}
}

\pagestyle{empty}


\begin{document}\sloppy

% % Example definitions.
% % --------------------
% \def\x{{\mathbf x}}
% \def\L{{\cal L}}


% Title.
% ------
\title{Chatroom Project}
%
% Single address.
% ---------------
\name{Gerard (Jed) Mijares, Andrew Perry}
%Address and e-mail should NOT be added in the submission paper. They should be present only in the camera ready paper. 
\address{}


\maketitle


%
% \begin{abstract}
% % The abstract should appear at the top of the left-hand column of text, about 0.5 inch (12 mm) below the title area and no more than 3.125 inches (80 mm) in length.  Leave a 0.5 inch (12 mm) space between the end of the abstract and the beginning of the main text.  The abstract should contain about 100 to 150 words, and should be identical to the abstract text submitted electronically along with the paper cover sheet.  All manuscripts must be in English, printed in black ink.



% \end{abstract}
%
% \begin{keywords}
% One, two, three, four, five
% \end{keywords}
%
\section{Introduction}
\label{sec:intro}
A critical function of the internet has always been allowing people to communicate with each other remotely. This has been especially relevant this year, as it is more difficult to meet with people in person as a result of the COVID-19 pandemic. Due to this, the group decided to create a chatroom application to explore this area firsthand. 

\begin{figure}[h]
\caption{Demonstration of clients chatting via our chatroom application}
\centering
\includegraphics[width=0.5\textwidth]{media/usersChatting.PNG}
\label{usersChatting}
\end{figure}

\subsection{Relevance to the Course}

The project most heavily builds on the content in Chapter 2 of Kurose's textbook, \emph{Computer Networking} \cite{kurose}. Specifically, the topics that were used are programming with sockets and sending messages or files back and forth. 

This project also relates to the material from Chapter 8 \cite{kurose}. These topics are security and end-to-end encryption. 

Getting experience with these concepts helped to understand and reinforce the real-world applications where they are used. For example, seeing the effect that no encryption has on the security of the messages. Without any security, the messages could be easily intercepted and read with a packet sniffer such as Wireshark. Actually programming and using these techniques reinforces the concept.

\section{Literature Review}

\subsection{Comparison to Internet Relay Chat (IRC)}

\begin{figure}[h]
\caption{Client/Server Network Architecture Diagram}
\centering
\includegraphics[width=0.5\textwidth]{media/Network.PNG}
\label{Network Architecture}
\end{figure}

Internet Relay Chat (IRC), the first popularized open chat protocol (but not the first!) was invented in 1988 and still has users today. Although more sophisticated chatroom applications discussed in section 2.2 have taken the majority of online chatroom users, IRC still retains a surprising amount of users. This could be due to its ease of use. IRC's ease of use is still attractive to users who wish to gather to discuss a wide range of topics. 

Similar to our protocol, it operates on a client server scheme, as shown in Figure \ref{Network Architecture}. Anybody who properly implements the protocol can connect to or create a server. 

Our protocol adds some features present in proprietary chat applications that are not available in "vanilla" IRC. (Though some users have created IRC extensions that add similar functions.)

Other open chat examples are XMPP and PSYC. 

\subsection{Comparison to Proprietary Applications}

Services such as Slack, Discord, and GroupMe are products offered that also offer chat applications. 

These applications are often robust and offer features that cater to a certain target market. For example, Slack is geared towards a professional work environment while Discord is designed for video game players to communicate. 

Unlike IRC and the chatroom application created for this project, these proprietary applications offer a standard client to use their service. It is not possible (or legal) to create a custom client to connect to these applications. However, some may offer Application Programming Interfaces (API) for people to create some sort of interface, such as bots. 

\subsection{Types of Encryption}

Encryption is a necessary aspect of chatroom applications; one that developers must keep in mind while creating applications. Without sufficient encryption, malicious onlookers will not only have the potential to read messages sent between users, but also to obtain personal information, such as passwords. One key aspect of our project is to begin developing our chatroom's encryption methods, beginning with the encryption of chat messages. 

One of the most trusted encryption techniques is the Advanced Encryption Standard (AES). AES is the encryption standard used by the United States government, banks, and many other corporations where encryption is massively important. One pro of AES are its use of "symmetric encryption", meaning that the same key that is used for encryption is also used for decryption. Another pro is that the large key sizes used by AES (supports 128, 192, and 256 bits) makes hacking encrypted data virtually impossible. The con of this method, however, is that AES encrypts in blocks of 128 bits, which can lead to a time consuming and memory intensive encryption and decryption process for very large files. 

Since text messages make up the majority of communication in our chatroom application, the pros of robust security and simple implementation outweigh the cons of time and memory intensiveness. 

Other options that were considered for this project were Salsa20 and Data Encryption Standard (DES). Both of these options were quickly ruled out in favor of AES. While Salsa20 has the potential to provide faster encryption times on large files, its use is not near as documented and established as AES. DES is a more well known encryption standard, but its short key length of 56 bits makes it much easier to crack. 

More information on AES and other encryption types can be found in ~\cite{encryption}.

\subsection{Architecture Options}

We explored two options for our chatroom network architecture: the server-client model or peer-to-peer (P2P). In this section, the pros and cons of each is discussed, and one is selected for our project. 

The client-server model is the most obvious option for our chatroom application. This is because client-server is used by nearly all chatroom applications. IRC, the first popularized chatroom application, used the client-server model shown in Figure 1, and all of the proprietary applications mentioned in section 2.2 make use of the client-server model. This is because the client-server model has many pros that make it ideal for these applications. Some examples are: 

\begin{itemize}
  \item easy control of servers, as programs or clients cannot easily damage the system,
  \item easy to maintenance servers as clients are not involved in the process,
  \item and ease to add more nodes to the network.
\end{itemize}

This architecture still has drawbacks. These include performance dips as the number of clients increase and potential for chatroom failure if one or more servers fail.~\cite{clientserver} gives additional info on the pros and cons of the client-server architecture.

Peer-to-peer (P2P) is an architecture that is rarely used for chatroom applications, but is still very popular. P2P is often used for file sharing applications, with the most notable protocol being BitTorrent. The pros of P2P include not needing to create and maintain expensive servers since the application is run on the client's device, and the failure of a single client will not lead to the destruction of the network, since each client is only a bit of the connection. (This is opposed to client-server, where the crashing of a server could have disastrous results.) A key downside to P2P is lower security, since clients have much more control over the workings of the program.

After researching this info, we decided to base our chatroom on a client-server model. This is because the client-server model allows for a higher degree of security when sending messages, and our chatroom will be operating on a small scale, so the key downside of the client-server model will not harm the chatroom performance. In order to keep the project from getting too complex, and to create a unique chatroom application from IRC, we decided to also send files over the client-server architecture as well.

\section{Technical Approach Description}

\subsection{Threaded Chat Program}

At first, we approached the challenge with a simple procedural program on each end of the chatroom. We quickly found this was insufficient - users could indeed communicate with each other, but only if they took turns sending messages to each other. Otherwise the program would hang, not allowing the user to continue to send messages until they had received one.

To solve the problem, we redirected the chatroom program using a multi-threaded approach for both the client and server.

\begin{figure}[h]
\caption{Beginning of Server Code}
\centering
\includegraphics[width=0.5\textwidth]{media/serverFlowchart2.png}
\label{server2}
\end{figure}

When the user decides to create a new server on their device, the program first creates a socket to handle new connections, then waits for clients to connect, as demonstrated in Figure \ref{server2}.

\begin{figure}[h]
\caption{Server code to connect to each client}
\centering
\includegraphics[width=0.5\textwidth]{media/serverFlowchart1.png}
\label{server1}
\end{figure}

When a client connects, the server creates a new thread to run the code loop demonstrated in Figure \ref{server1}. The object running this thread is appended to a list of active client connections. When a message is sent from the server, the server will go through this list and forward the message to each client.

\begin{figure}[h]
\caption{Code running at beginning of Client Program}
\centering
\includegraphics[width=0.5\textwidth]{media/clientFlowchart2.png}
\label{client2}
\end{figure}

When the user decides to connect to a server as a client, the code described in Figure \ref{client2} is run. First, the user is prompted for information including the IP address of the server they are connecting to, the username they would like to use, and the encryption key they will use. Then, two threads are created, one to handle sending and one for receiving.

\begin{figure}[h]
\caption{Code loop to handle sending messages to the server}
\centering
\includegraphics[width=0.5\textwidth]{media/clientFlowchart1.png}
\label{client1}
\end{figure}

Figure \ref{client1} gives an overview of the code facilitating the sending of messages from client to server. The program waits for input from the user, and when a message is entered, it checks for a command at the beginning of the message. Currently, the only command available is "!send" to send a file, but other commands could be implemented in the future as well. If no command is present, then the message is encrypted and sent to the server.

\begin{figure}[h]
\caption{Client code to receive messages from the server}
\centering
\includegraphics[width=0.5\textwidth]{media/clientFlowchart3.png}
\label{client3}
\end{figure}

Finally, the code describing the receiving of messages is described in Figure \ref{client3}. Each client will wait for a message to arrive from the server, and will then check the messages header to determine what kind of processing is required. For a text message, that is decrypting the message and printing it to the screen, and for a sent file, that is parsing the filename and writing the file itself to that file.

\subsection{Encryption}

% Used a form of AES encryption, blah blah
After the selection process for encryption types discussed in section 2.3, we decided to implement a form of AES encryption. There are many Python libraries that implement this exact architecture, many operating in similar ways. We decided to use the Fernet library in Python's Cryptography suite. 

When a client first connects to a server, they are asked to provide an encryption key, as shown in Figure 7. Since AES uses symmetrical encryption, this is the key that will be used to both encrypt outgoing messages and decrypt incoming messages. Clients will be able to communicate successfully only if they have already agreed on a key beforehand. 

After a client has connected, the key that they input will be used to encrypt and decrypt. If two clients have entered equivalent keys, then their messages will be successfully transferred. If a client attempts to decode a message with a different key, the decryption function will fail, and the message "ERROR: ENCRYPTION KEY IS DIFFERENT" will show instead of the intended message. 

The only complication in this method occurred on the decryption side. When a client-inputted message is encrypted, the encrypted message is contained as a bit string. This encrypted message is received as a string on the receiving end. This string had to be casted back to a bit string in order to work with the Fernet decryption function.

\begin{figure}[h]
\caption{The client is asked for an IP, username and encryption key before connecting to the server.}
\centering
\includegraphics[width=0.5\textwidth]{media/StartCode.PNG}
\label{client3}
\end{figure}

\subsection{File Sharing}

As mentioned previously, the user may send a file located on their device with "!send \emph{filename}". When this occurs, the client first sends a short message with the header "FILE" (as opposed to the "TEXT" of a general chat message). This initial message contains the file's name and its size. After sending this message, the client begins sending the file sequentially, until the entire file has been sent. This process is shown in Figure \ref{client1}.

When the server receives the "FILE" header message, it first parses the given file name and size. Then, it opens a file with the given file name and begins to write the data sent from the client into that file. Once complete, it sends the file to each connected client, just as the client sent it to the server. This process is shown in Figure \ref{server1}.

Finally, the receiving clients receives the "FILE" message and file data from the server, as shown in Figure \ref{client3}. The user is able to use the file as they wish. A practical use of this feature is shown in Figure \ref{fileshareDemo}.

\begin{figure}[h]
\centering
\caption{Demonstration of filesharing application}
\includegraphics[width=0.5\textwidth]{media/fileshareDemo.png}
\label{fileshareDemo}
\end{figure}

Unlike text messages, files are not currently encrypted. Other potential improvements to this feature that could be added in the future include error handling if a file is not present, parallelizing the sending of the file, and automatically displaying the file in the receiver's default application for the given file type.

\section{Experimental Results and Discussion}

\subsection{Encryption}

\begin{figure*}[h]
\centering
\includegraphics[width=1\textwidth]{media/WiresharkEncryptionResults.PNG}
\label{Encryption Wireshark Results}
\caption{Results of Encryption on Legibility of Wireshark Captures. The capture on the left is from an encrypted message, while the capture on the right is from a non-encrypted message. The capture on the left is illegible, while the non-encrypted capture can be read directly.}
\end{figure*}

Two tests were run to make sure that the encryption method was actually working. First, the effectiveness of encryption was shown in the chatroom itself. To make sure that the encryption method actually prevented users with different encryption keys from viewing each other's messages, three clients were connected to a localhost server. Two of these clients have equivalent encryption keys, while the third user has a different key. If the encryption method works correctly, the two users with equivalent keys will be able to read each other's messages, while the third user will only see the error message described in section 3.2. Similarly, the two users should not be able to read the messages from the third user with a different key. 

The results of this experiment are shown in Figure \ref{Encryption Results Figure}. The clients with usernames "Andrew" and "Jed" both have the same encryption key, while "random guy" has a different key. As expected, the users Andrew and Jed were able to read each other's messages, while Random guy could only see an error code. Additionally, users Andrew and Jed could not read the messages that Random guy sent. 

The purpose of the second experiment is to 

\begin{figure}[h]
\centering
\caption{Results of the first experiment to show the effectiveness of encryption.}
\includegraphics[width=0.5\textwidth]{media/EncryptionExperiment.PNG}
\label{Encryption Results Figure}

\end{figure}

\subsection{File Sharing}
We found we were successfully able to send files from one computer to another. However, we noticed that the received files sometimes had slight errors in transmission. For example, pictures might send, but have a small gray rectangle near the bottom. It seems something in the code may have been cutting off the transmission early for larger files, but we were not able to fully debug this issue. So, while this application may be sufficient casual sending of files such as images and text documents, it can fail for more complex files.

% \section{Discussions on Results}

\section{Division of Labor}

The division of labor is as follows.

Jed - 
\begin{itemize}
  \item Multi-threaded chat program
  \item File transfer
  \item Code flowcharts
\end{itemize}

Andrew - 
\begin{itemize}
  \item Encryption
  \item Encryption Wireshark experiment. 
\end{itemize}

\section{Conclusion}

To summarize, the project successfully completed all of our goals. We created a TCP chatroom program that is similar to IRC, while providing some extra features. 

Given more time, the next set of objectives would be as follows: 
\begin{itemize}
  \item Caching messages
  \item Private messages
  \item Improving robustness/error handling
  \item improved user interface, and
  \item Encryption/decryption of files. 
\end{itemize}

% \section{Citations and References}

% List and number all bibliographical references at the end of the paper. The references can be numbered in alphabetic order or in order of appearance in the document. When referring to them in the text, type the corresponding reference number in square brackets as shown at the end of this sentence. All citations must be adhered to IEEE format and style. Examples such asand~\cite{kurose}, ~\cite{encryption}, ~\cite{clientserver} are given in Section 12.

% References should be produced using the bibtex program from suitable
% BiBTeX files (here: strings, refs, manuals). The IEEEbib.bst bibliography
% style file from IEEE produces unsorted bibliography list.
% -------------------------------------------------------------------------
\bibliographystyle{IEEEbib}
\bibliography{icme2020template}

\end{document}
